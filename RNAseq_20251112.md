# RNA-seq実習コマンドリスト（2日目）

Date: 12-Nov-2025  

RNA-seq解析実習で使うRコードのリスト

## 解析手順

1. データダウンロード
2. クオリティコントロール
3. ゲノム配列へのアライメント
4. リード数のカウント
5. 発現解析
6. GOエンリッチメント解析

２日目は5〜6を行う

## 0. 全リードデータを使った結果のダウンロード

下記リンクから、全リードデータを使った結果ファイル３つをダウンロードする  

- counts_all.txt
- qc_results_all_mod.txt
- hisat_results_all_mod.txt

<https://x.gd/7Wf19>

まとめてダウンロードすると圧縮されて面倒なので、１つずつ、Rmarkdownファイルがある場所にダウンロードすること。

## 5. 発現解析

### まず、必要なパッケージの読み込み

```R
# 発現解析用パッケージ: edgeR, DESeq2
library(edgeR)
library(DESeq2)
# データ処理用パッケージ：dplyr, stringr
library(dplyr)
library(stringr)
# 可視化、作図用パッケージ：gplots, ggplot2, ggdendro
library(gplots)
library(ggplot2)
library(ggdendro)
```

### 5-1. リード数の正規化

NGSで得られたリード数は、サンプル間で必ずしも均一ではない。  
ばらつきの原因は  
- 発現量の個体差
- サンプルのRNA量
- 遺伝子ごとのライブラリ調整時のPCR効率の違い
- リードごとのシークエンスの効率
など。

また、遺伝子・転写産物の長さもそれぞれ異なるため、リード数を数えただけでは、正確な発現量比較ができない。  
（長い遺伝子ほどリードが多くなる傾向がある）

##### 正規化

遺伝子発現量を正確に定量するために、リード数を正規化、つまりサンプル間のばらつきや遺伝子長の違いを補正すること。  
様々な方法が提案されている。下記は代表的な正規化方法。

1. CPM (counts per million): リード数を100万本に揃える。
2. FPKM （fragments per kilobase of exon per million reads mapped）、またはRPKM (Reads per kilobase of exon per million mapped reads): リード数を100万本に揃えてから、転写産物長を1000 bpに揃える
3. TPM (transcripts per milion): 転写産物を1000 bpに揃えてから、リード数を100万本に揃える
4. TMM (Trimmed mean of M values): TPM正規化に加えて、ハウスキーピング遺伝子(常に同じ量発現している遺伝子)の発現量でも標準化する

今回は、現状最も正確に正規化できると言われるTMM正規化を行う。

#### edgeRパッケージを使ったTMM正規化

```R
# カウントデータの読み込み
data <- read.table("counts_all.txt", header = T, row.names = 1, sep = "\t")
head(data)

# 不要な列を削除
# 発現解析には遺伝子名とリード数データのみを使うので、デフォルトで含まれる他の列を削除
data2 <- dplyr::select( # dplyr::select: 列の選択・削除
  data,
  -contains(c( # -contains: 指定した文字列を含む列を削除
    "Chr", "Start",
    "End", "Strand", "Length"
  ))
)
head(data2)

# 比較対象のグループを設定
# edgeRはアルファベット順にグループを認識して、アルファベットの若い方を基準にするため、controlとcoldではcoldが基準になってしまう。
# ここではa_control、b_coldとして命名し直し、controlを基準にしたcoldの発現量を算出させる。
group <- factor(c(
  "b_cold", "b_cold", "b_cold",
  "a_control", "a_control", "a_control"
))
design <- model.matrix(~group)

# 正規化
# まずグループ間で発現量を比較する
d <- DGEList(counts = data2, group = group)

## 正規化して、分散を推定する
d1 <- calcNormFactors(d)
d1 <- estimateGLMCommonDisp(d1, design)
d1 <- estimateGLMTrendedDisp(d1, design)
d1 <- estimateGLMTagwiseDisp(d1, design)

# 正規化の数値を一般化線型モデルで近似して、controlとcoldで発現量を比較
fit1 <- glmFit(d1, design)
lrt1 <- glmLRT(fit1, coef = 2)

# 正規化して発現量を比較した結果表にする
table1 <- as.data.frame(topTags(lrt1, n = nrow(count)))
# print(head(table1))

# 表を出力
write.table(table1,
  file = "Comp.txt",
  col.names = T, row.names = T, sep = "\t", quote = FALSE
)
```

ここまでで作成したd1オブジェクトに、TMM正規化されたリード数情報が含まれている。  
また、comp.txtファイルには、各遺伝子の発現変動情報（コントロールに比べて低温でどれだけ発現が変化したか）が含まれている。  
d1やtable1 (comp.txtが格納されたオブジェクト)を使って、各種解析を行う。

### 5-2. サンプルクオリティの確認：　MDSプロットの作成

多次元尺度構成法： 多次元のデータを低次元に（例えば２次元）に変換する方法。  
１万個以上の遺伝子について、それぞれのサンプルの発現量を扱っているので、データの次元は少なく見積もっても１万x６次元。  
これを１つ１つ見比べることはできないので、２次元などの低次元に変換して比較する。  
これによって、サンプル同士が似ているかどうか、変なサンプルが混ざっていないかを確かめる。

原理は
1. サンプル間の距離行列を計算する（似ていれば0、違っていれば１）
2. サンプル同士の距離の近さを２次元にプロットする

Rの`plotMDS`関数を使うと簡単に作成できる。

```R
# Multi-dimensional scaling plot
plotMDS(d1)

# MDS plotを保存
png("MDSplot.png", bg = "transparent")
plotMDS(d1)
dev.off()
```

### 5-3. 発現量のクラスタリング

##### 階層クラスタリング

ある集合をなんらかの規則によって分類すること。  
RNA-seq解析の場合、「サンプル間（遺伝子間）の発現パターンが似ているか？」に基づいてグループ分けする。  
クラスタリングの結果は、系統樹やヒートマップで可視化される。

```R
# 発現量上位1000遺伝子を抽出（ここでは遺伝子名だけ拾われる）
top_deg <- table1 %>%
  arrange(FDR) %>%
  slice_head(n = 1000)
head(top_deg)

# 上位1000遺伝子名を元に、それぞれの発現量データを結合
top_count <- data2[rownames(top_deg), ]
head(top_count)

# 正規化とスケーリング
scaledata <- t(scale(t(top_count))) 
scaledata <- scaledata[complete.cases(scaledata), ]

# 階層クラスタリングして発現量のヒートマップをかく
png("Cluster_hm.png")
heatmap.2(
  scaledata,
  dendrogram = "both", # 列と行の両方をクラスタリング
  trace = "none", # トレース線を消す
  col = colorRampPalette(c("blue", "white", "red"))(50), # カラースケールを指定
  scale = "none", # すでにスケーリング済みなので、ここでは指定しない
  labRow = NA, # 行ラベルを非表示(遺伝子が多すぎて混み合うので)
  labCol = colnames(scaledata), # 列ラベルを表示(サンプル名)
  main = "Clustered Heatmap of Top 1000 DEGs", # グラフタイトルを指定
  key = TRUE, # カラースケールの凡例を表示
  density.info = "none", # 密度情報を非表示
  margins = c(10, 10) # 余白を調整
)
```

### 5-4. DEGsの検出と可視化

DEGs: Differentially Expressed Genes (発現変動遺伝子)  
ある条件下で発現量が有意に変動する遺伝子をDEGsと呼ぶ。  
今回の場合、コントロール群に比べて低温処理群で発現量が有意に変動する遺伝子をDEGsとする。  
論文などでは、コントロールに比べて発現が上昇した遺伝子をup-regulated DEGs、発現が低下した遺伝子をdown-regulated DEGsと呼ぶことが多い。  

- 処理１と処理２で発現量は何倍変わっているか？
- その変化は統計的に有意か？
を調べることで、DEGsを検出する。

#### DEGsの抽出

```R
# DEGを検出 (FDR < 0.01かつ発現変動量２倍以上)
FDR <- as.logical(table1$FDR < 0.01 & abs(table1$logFC) >= 1) # logical (true、false)の判定付きで変換。
DEG_names <- rownames(table1)[FDR] # trueだけDEG.namesに収納

# DEGを表に出力 (FDR < 0.01)
DEGs <- subset(table1, FDR < 0.01)
write.table(DEGs,
  file = "DEGs.txt",
  col.names = T, row.names = T, sep = "\t", quote = FALSE
)
```

全遺伝子のうち、up-regulated DEGsとdown-regulated DEGsがどれくらいあるかを可視化する方法は多くある。  
今回は比較的よく使われるMAプロットとVolcanoプロットを作成する。

#### MAプロット

MAプロットは、各遺伝子の発現変動量（M値）を縦軸に、平均発現量（A値）を横軸にとった散布図。  
指定した閾値を超える発現変動量を持つ遺伝子をDEGsとして色分けする。  
正しく正規化されており、ばらつきが少ない場合、平均発現量が低い遺伝子ほど発現変動量が大きくなる傾向がある。  
そのため、サンプルクオリティが良ければ、横軸に対して線対象な分布になる。

```R
# MA plot
plotSmear(lrt1, de.tags = DEG_names, cex = 0.3)

# MA plotを保存
png("MAplot.png", bg = "transparent")
print(plotSmear(lrt1, de.tags = DEG_names, cex = 0.3))
dev.off()
```

#### Volcanoプロット

Volcanoプロットは、各遺伝子の発現変動量（log2FC）を横軸に、統計的有意性（-log10 p値）を縦軸にとった散布図。  
指定した閾値を超える発現変動量と有意性を持つ遺伝子をDEGsとして色分けする。  
火山が噴火したような形になることから、Volcanoプロットと呼ばれる。

```R
## カウントデータに、DEGとして色分けするための閾値情報を追加
countdata <- mutate(table1, thcolor = ifelse(FDR >= 0.01, 0,
  ifelse(logFC >= 1, 1,
    ifelse(logFC <= -1, 2, 0)
  )
))

vol <- ggplot() +
  geom_point(aes(x = countdata$logFC, y = -log10(countdata$FDR), color = as.factor(countdata$thcolor)), size = 0.1) +
  labs(x = "log2 (Fold Change)", y = "-log10 (p-value)") +
  scale_color_manual(values = c("black", "red", "blue")) + # 色分けの指定
  theme_bw() + # テーマの指定
  geom_hline(yintercept = -log10(0.01), size = 0.2, color = "red") +
  geom_vline(xintercept = -1, size = 0.2, color = "red") +
  geom_vline(xintercept = 1, size = 0.2, color = "red") + # 発現変動量の閾値線を作成
  theme(legend.position = "none", panel.grid = element_blank())
vol
ggsave(vol, file = "volcano.png", dpi = 200, bg = "transparent")
```

## 6. GOエンリッチメント解析 (Gene Ontology Enrichment Analysis)

GO (Gene Ontology) エンリッチメント解析は、DEGs（発現変動遺伝子）に共通して見られる生物学的機能や経路を調べる手法。  
DEGsリストをGOデータベースに照合し、「特定の機能（GO項目）がDEGsの中で過剰に含まれているか」を統計的に検定する。

例：ゲノム全体では 2% しか含まれない GO 項目が、DEGsの中では 10% 含まれていたら、その機能が特異的に関係している可能性がある。

### 6-1. 必要なパッケージの読み込み

```R
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("org.At.tair.db")

# GO解析
library(topGO)
library(org.At.tair.db)  # Arabidopsis用GOアノテーション

# データ処理
library(tidyverse)
```

### 6-2. 入力データの準備

RNA-seq解析の結果（例：Comp.txt）には、遺伝子ID、logFC、P値、FDRなどが含まれる。  
ここでは、**「FDR ≤ 0.05」**を有意なDEGとして定義する。

```R
# Comp.txtの読み込み
df <- read_tsv("Comp.txt", show_col_types = FALSE)

# 列名が無い場合の補正
if (!"ID" %in% names(df)) names(df)[1] <- "ID"

# transcript:接頭辞や .1 などのトランスクリプト番号を除去
library(stringr)
df <- df %>%
  mutate(ID = ID %>%
           str_remove("^transcript:") %>%
           str_remove("\\.\\d+$"))

# org.At.tair.dbに存在するTAIR IDのみを残す
valid <- AnnotationDbi::keys(org.At.tair.db, keytype = "TAIR")
df <- df %>% filter(TAIR %in% valid)

# 同一遺伝子に複数トランスクリプトがある場合、最小FDRで代表
df <- df %>% arrange(TAIR, FDR) %>% distinct(TAIR, .keep_all = TRUE)

# FDR < 0.01 かつ、２倍以上変動（|logFC| > 1）をDEGとする
df <- df %>% mutate(isDEG = FDR <= 0.01 & abs(logFC) > 1)
```

### 6-3. gene universe（全遺伝子集合）の作成

topGOは、全遺伝子の中で「DEGであるかどうか（1 or 0）」をfactorとして渡す必要がある。

```R
gene_universe <- factor(as.integer(df$isDEG))
names(gene_universe) <- df$TAIR

summary(gene_universe)
# 例: 0 = 非DEG, 1 = DEG の数が表示される
```

### 6-4. topGOデータの作成と検定

ここでは、Fisherの正確確率検定を用いて、各GO項目のうち、DEGsで濃縮している項目を検定する。  
run_topgo関数を定義することで、同じコードを複数書くことなく、BP/MF/CCの解析を簡単に実行できる。  

```R
# run_topgo関数の定義
run_topgo <- function(allGenes_vec, ontology = c("BP","MF","CC")) {
  ontology <- match.arg(ontology)

  GO <- new("topGOdata",
            ontology = ontology,
            allGenes = allGenes_vec,
            annotationFun = annFUN.org,
            mapping = "org.At.tair.db",
            ID = "TAIR")

  # elimアルゴリズム + Fisher検定を実行
  test <- runTest(GO, algorithm = "elim", statistic = "fisher")

  # 有意なGOを上位に並べる
  topN <- max(1, sum(score(test) < 0.05, na.rm = TRUE))  # ← ここはGOごとのp値閾値（後述）
  tab <- GenTable(GO, elimFisher = test,
                  orderBy = "elimFisher", ranksOf = "elimFisher",
                  topNodes = topN)

  # 結果を出力
  write_tsv(tab, paste0("topGO_", ontology, "_table.txt"))

  # シグニフィカントなノードを可視化
  png(paste0("topGO_", ontology, ".png"), 1500, 1500)
  par(cex = 0.5)
  showSigOfNodes(GO, score(test), useInfo = "def")
  dev.off()

  tab
}

# 実行（BP: Biological Process, MF: Molecular Function, CC: Cellular Component）
tab_BP <- run_topgo(gene_universe, "BP")
tab_MF <- run_topgo(gene_universe, "MF")
tab_CC <- run_topgo(gene_universe, "CC")
```

### 6-5. ２種類のp値について

２つのp値、FDR値が出てくるが、独立の統計検定の結果得られるものなので、混同しないように注意する。

- `df$isDEG = FDR <= 0.01` は「遺伝子発現レベルの有意差判定」
- `score(test) < 0.05` は「GOカテゴリの有意差判定」

| 種類        | 出現箇所 | 意味                                | 主な使い方                    |
| ----------- | -------- | ----------------------------------- | ----------------------------- |
| FDR         | DEG検出  | 各遺伝子が有意に発現変動しているか  | DEGリストを作る時の有意性検定 |
| score(test) | GO解析   | 各GO項目にDEGが過剰に含まれているか | GO enrichmentの有意性を判断   |

### 6-6. GO解析結果を棒グラフで可視化

topGOのテーブル出力を利用して、有意なGO項目を視覚的に比較する。  
棒グラフ（barplot）はカテゴリ名とp値の関係を示し、ドットプロット（dotplot）は注釈遺伝子数（Gene Count）も併せて可視化できる。

今回は上位20項目を抽出して、棒グラフ、ドットプロットを作成する。

#### ライブラリの読み込み

```R
library(ggplot2)
library(dplyr)
library(stringr)
```

#### 上位20のGO項目を抽出

```R
# topGO出力ファイルの読み込み（BPを例に）
tab_BP <- read_tsv("topGO_BP_table.txt", show_col_types = FALSE)

# p値を数値化してFDR補正
tab_BP <- tab_BP %>%
  mutate(elimFisher = as.numeric(elimFisher)) %>%
  mutate(FDR = p.adjust(elimFisher, method = "fdr")) %>%
  arrange(FDR)

# 上位20項目のみ抽出
top_BP <- tab_BP %>% slice_min(FDR, n = 20)

# 説明の長いGO termを改行して整形（図が読みやすくなる）
top_BP$Term <- str_wrap(top_BP$Term, width = 45)
```

#### 棒グラフの作成

`−log10(p値)`を高さとして、FDRの低い項目ほど高く表示。  
※p値が小さい＝有意＝バーが高い。

```R
ggplot(top_BP, aes(x = reorder(Term, -elimFisher), y = -log10(elimFisher))) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(title = "GO enrichment (Biological Process)",
       x = "GO term",
       y = expression(-log[10](italic(p)))) +
  theme_bw(base_size = 12)
ggsave("GO_BP_barplot.png", width = 7, height = 6, dpi = 300)
```

#### ドットプロットの作成

注釈遺伝子数（Significant）をドットサイズで表現し、p値を色で示す。  
機能カテゴリーの規模感も直感的に理解できる形で作図する。

```R
ggplot(top_BP, aes(x = -log10(elimFisher), y = reorder(Term, -elimFisher))) +
  geom_point(aes(size = Significant, color = -log10(elimFisher))) +
  scale_color_gradient(low = "skyblue", high = "darkblue") +
  labs(title = "GO enrichment (Biological Process)",
       x = expression(-log[10](italic(p))),
       y = "GO term",
       size = "Gene count",
       color = "-log10(p)") +
  theme_bw(base_size = 12)
ggsave("GO_BP_dotplot.png", width = 7, height = 6, dpi = 300)
```

#### 図の解釈のポイント

| 要素            | 意味         | 説明                                       |
| --------------- | ------------ | ------------------------------------------ |
| **Term**        | GO項目の名前 | 生物学的プロセス・分子機能・細胞構成など   |
| **elimFisher**  | topGOのp値   | DEGsがそのGO項目に過剰に含まれる確率       |
| **Significant** | GO内のDEG数  | どの程度の遺伝子がその機能に関係しているか |
| **−log10(p)**   | 有意度の強さ | 値が大きいほど有意                         |

#### 図の調整ポイント

| 調整箇所                             | 内容                                             |
| ------------------------------------ | ------------------------------------------------ |
| `slice_min(FDR, n = 20)`             | 上位10～30項目に変更可能                         |
| `width = 45`                         | GO名の折り返し幅を調整（長い場合は小さく）       |
| `fill` または `scale_color_gradient` | カラーパレット変更（例："PuBu", "viridis" など） |
| `coord_flip()`                       | 横向き表示を縦向きに変更する場合は削除           |
